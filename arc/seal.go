package arc

import (
	"bufio"
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/ed25519"
	"crypto/rand"
	"crypto/rsa"
	"fmt"
	"strings"
	"time"
)

// Sealer provides ARC message sealing.
type Sealer struct {
	// Domain is the signing domain (d= tag).
	Domain string

	// Selector is the selector for the signing key (s= tag).
	Selector string

	// PrivateKey is the signing key.
	// Supported types: *rsa.PrivateKey, ed25519.PrivateKey, *ecdsa.PrivateKey
	PrivateKey crypto.Signer

	// Headers is the list of headers to sign in ARC-Message-Signature.
	// If empty, DefaultSignedHeaders is used.
	Headers []string

	// HeaderCanonicalization is the header canonicalization algorithm.
	// Default is CanonRelaxed.
	HeaderCanonicalization Canonicalization

	// BodyCanonicalization is the body canonicalization algorithm.
	// Default is CanonRelaxed.
	BodyCanonicalization Canonicalization

	// Clock is used for timestamp generation.
	// If nil, time.Now is used.
	Clock func() time.Time
}

// DefaultSignedHeaders is the default list of headers to sign in ARC-Message-Signature.
var DefaultSignedHeaders = []string{
	"From",
	"To",
	"Cc",
	"Subject",
	"Date",
	"Message-ID",
	"In-Reply-To",
	"References",
	"MIME-Version",
	"Content-Type",
	"Content-Transfer-Encoding",
	"Content-Disposition",
	"Reply-To",
	"Received",
	"ARC-Authentication-Results",
	"ARC-Message-Signature",
	"ARC-Seal",
	"DKIM-Signature",
}

// SealResult contains the headers generated by sealing.
type SealResult struct {
	// AuthenticationResults is the ARC-Authentication-Results header.
	AuthenticationResults string

	// MessageSignature is the ARC-Message-Signature header.
	MessageSignature string

	// Seal is the ARC-Seal header.
	Seal string

	// Instance is the ARC set instance number.
	Instance int
}

// Seal creates a new ARC set for the message.
// The authResults parameter should contain the authentication results observed by this intermediary.
// The chainValidation parameter indicates the validation status of any existing ARC chain.
//
// Returns the three ARC headers that should be prepended to the message.
func (s *Sealer) Seal(message []byte, authServID, authResults string, chainValidation ChainValidationStatus) (*SealResult, error) {
	// Parse existing ARC headers to determine instance number
	br := bufio.NewReader(bytes.NewReader(message))
	headers, bodyOffset, err := parseHeaders(br)
	if err != nil {
		return nil, fmt.Errorf("parsing message: %w", err)
	}

	// Determine instance number
	maxInstance := 0
	for _, h := range headers {
		switch h.lkey {
		case "arc-seal":
			seal, _, _ := ParseSeal(extractHeaderValue(h.raw))
			if seal != nil && seal.Instance > maxInstance {
				maxInstance = seal.Instance
			}
		}
	}

	instance := maxInstance + 1
	if instance > MaxInstance {
		return nil, ErrInstanceTooHigh
	}

	// Validate chainValidation consistency
	if instance == 1 && chainValidation != ChainValidationNone {
		return nil, fmt.Errorf("%w: first instance must have cv=none", ErrChainValidationMismatch)
	}
	if instance > 1 && chainValidation == ChainValidationNone {
		return nil, fmt.Errorf("%w: subsequent instances cannot have cv=none", ErrChainValidationMismatch)
	}

	// Get algorithm
	alg, hashAlg, err := s.getAlgorithm()
	if err != nil {
		return nil, err
	}

	hashFunc, ok := getHash(hashAlg)
	if !ok {
		return nil, fmt.Errorf("%w: %s", ErrHashUnknown, hashAlg)
	}

	// Create ARC-Authentication-Results header
	aar := &AuthenticationResults{
		Instance:   instance,
		AuthServID: authServID,
		Results:    authResults,
	}
	aarHeader := aar.Header()

	// Create ARC-Message-Signature
	ms := &MessageSignature{
		Instance:   instance,
		Version:    1,
		Algorithm:  string(alg),
		Domain:     s.Domain,
		Selector:   s.Selector,
		Timestamp:  s.now().Unix(),
		Expiration: -1, // Not set
		Length:     -1, // Not set
	}

	// Set canonicalization
	headerCanon := s.HeaderCanonicalization
	if headerCanon == "" {
		headerCanon = CanonRelaxed
	}
	bodyCanon := s.BodyCanonicalization
	if bodyCanon == "" {
		bodyCanon = CanonRelaxed
	}
	ms.Canonicalization = string(headerCanon) + "/" + string(bodyCanon)

	// Get headers to sign
	signedHeaders := s.Headers
	if len(signedHeaders) == 0 {
		signedHeaders = DefaultSignedHeaders
	}

	// Filter to only headers present in the message
	presentHeaders := make(map[string]int)
	for _, h := range headers {
		presentHeaders[h.lkey]++
	}

	var finalSignedHeaders []string
	for _, h := range signedHeaders {
		lh := strings.ToLower(h)
		if presentHeaders[lh] > 0 {
			finalSignedHeaders = append(finalSignedHeaders, h)
		}
	}

	// Ensure From is signed
	hasFrom := false
	for _, h := range finalSignedHeaders {
		if strings.EqualFold(h, "from") {
			hasFrom = true
			break
		}
	}
	if !hasFrom {
		finalSignedHeaders = append([]string{"From"}, finalSignedHeaders...)
	}

	ms.SignedHeaders = finalSignedHeaders

	// Compute body hash
	body := message[bodyOffset:]
	bodyHasher := hashFunc.New()
	bodyHash, err := computeBodyHash(bodyHasher, bodyCanon, bytes.NewReader(body), -1)
	if err != nil {
		return nil, fmt.Errorf("computing body hash: %w", err)
	}
	ms.BodyHash = bodyHash

	// Compute ARC-Message-Signature
	// First generate header without signature
	amsHeaderPartial := ms.Header(false)

	// Create temporary headers list including the new AAR
	tempHeaders := make([]headerData, 0, len(headers)+1)
	tempHeaders = append(tempHeaders, headerData{
		raw:  []byte(aarHeader + "\r\n"),
		lkey: "arc-authentication-results",
	})
	tempHeaders = append(tempHeaders, headers...)

	// Compute data hash for AMS
	dataHasher := hashFunc.New()
	dataHash, err := computeAMSDataHash(dataHasher, headerCanon, tempHeaders, finalSignedHeaders, []byte(amsHeaderPartial+"\r\n"))
	if err != nil {
		return nil, fmt.Errorf("computing AMS data hash: %w", err)
	}

	// Sign
	amsSignature, err := signWithKey(s.PrivateKey, hashFunc, dataHash)
	if err != nil {
		return nil, fmt.Errorf("signing AMS: %w", err)
	}
	ms.Signature = amsSignature
	amsHeader := ms.Header(true)

	// Create ARC-Seal
	seal := &Seal{
		Instance:        instance,
		Version:         1,
		Algorithm:       string(alg),
		Domain:          s.Domain,
		Selector:        s.Selector,
		ChainValidation: chainValidation,
		Timestamp:       s.now().Unix(),
	}

	// Compute seal signature
	// The seal covers all ARC headers from i=1 to i=n
	// Create the full set for seal computation
	allSets := make([]*Set, instance)
	for i := 0; i < instance-1; i++ {
		// Extract existing sets from headers
		allSets[i] = &Set{Instance: i + 1}
	}
	allSets[instance-1] = &Set{
		Instance:              instance,
		AuthenticationResults: aar,
		MessageSignature:      ms,
		Seal:                  seal,
	}

	// Build headers list for seal computation
	sealHeaders := make([]headerData, 0)

	// Add the new ARC headers
	sealHeaders = append(sealHeaders, headerData{
		raw:  []byte(aarHeader + "\r\n"),
		lkey: "arc-authentication-results",
	})
	sealHeaders = append(sealHeaders, headerData{
		raw:  []byte(amsHeader + "\r\n"),
		lkey: "arc-message-signature",
	})
	// Add existing ARC headers
	for _, h := range headers {
		if h.lkey == "arc-authentication-results" ||
			h.lkey == "arc-message-signature" ||
			h.lkey == "arc-seal" {
			sealHeaders = append(sealHeaders, h)
		}
	}

	// Compute seal data hash
	sealDataHash, err := computeSealDataHashForSigning(hashFunc, instance, sealHeaders, seal)
	if err != nil {
		return nil, fmt.Errorf("computing seal data hash: %w", err)
	}

	// Sign seal
	sealSignature, err := signWithKey(s.PrivateKey, hashFunc, sealDataHash)
	if err != nil {
		return nil, fmt.Errorf("signing seal: %w", err)
	}
	seal.Signature = sealSignature
	asHeader := seal.Header(true)

	return &SealResult{
		AuthenticationResults: aarHeader,
		MessageSignature:      amsHeader,
		Seal:                  asHeader,
		Instance:              instance,
	}, nil
}

// computeSealDataHashForSigning computes the seal data hash for signing.
func computeSealDataHashForSigning(hashFunc crypto.Hash, instance int, headers []headerData, newSeal *Seal) ([]byte, error) {
	hasher := hashFunc.New()

	// Organize headers by instance
	aarHeaders := make(map[int]headerData)
	amsHeaders := make(map[int]headerData)
	asHeaders := make(map[int]headerData)

	for _, hdr := range headers {
		switch hdr.lkey {
		case "arc-authentication-results":
			aar, _ := ParseAuthenticationResults(extractHeaderValue(hdr.raw))
			if aar != nil {
				aarHeaders[aar.Instance] = hdr
			}
		case "arc-message-signature":
			ms, _, _ := ParseMessageSignature(extractHeaderValue(hdr.raw))
			if ms != nil {
				amsHeaders[ms.Instance] = hdr
			}
		case "arc-seal":
			seal, _, _ := ParseSeal(extractHeaderValue(hdr.raw))
			if seal != nil {
				asHeaders[seal.Instance] = hdr
			}
		}
	}

	// Hash ARC-Authentication-Results (i=1 to i=n)
	for i := 1; i <= instance; i++ {
		hdr, ok := aarHeaders[i]
		if !ok {
			return nil, fmt.Errorf("%w: missing AAR for instance %d", ErrInvalidChain, i)
		}
		canonHeader, err := canonicalizeHeaderRelaxed(hdr.raw)
		if err != nil {
			return nil, err
		}
		hasher.Write([]byte(canonHeader))
		hasher.Write([]byte("\r\n"))
	}

	// Hash ARC-Message-Signature (i=1 to i=n)
	for i := 1; i <= instance; i++ {
		hdr, ok := amsHeaders[i]
		if !ok {
			return nil, fmt.Errorf("%w: missing AMS for instance %d", ErrInvalidChain, i)
		}
		canonHeader, err := canonicalizeHeaderRelaxed(hdr.raw)
		if err != nil {
			return nil, err
		}
		hasher.Write([]byte(canonHeader))
		hasher.Write([]byte("\r\n"))
	}

	// Hash ARC-Seal (i=1 to i=n, with empty b= for i=n)
	for i := 1; i <= instance; i++ {
		var rawHeader []byte

		if i == instance {
			// Generate the new seal header with empty b=
			rawHeader = []byte(newSeal.Header(false) + "\r\n")
		} else {
			hdr, ok := asHeaders[i]
			if !ok {
				return nil, fmt.Errorf("%w: missing AS for instance %d", ErrInvalidChain, i)
			}
			rawHeader = hdr.raw
		}

		canonHeader, err := canonicalizeHeaderRelaxed(rawHeader)
		if err != nil {
			return nil, err
		}

		if i == instance {
			// Last header without trailing CRLF
			hasher.Write([]byte(canonHeader))
		} else {
			hasher.Write([]byte(canonHeader))
			hasher.Write([]byte("\r\n"))
		}
	}

	return hasher.Sum(nil), nil
}

// getAlgorithm determines the signing algorithm based on the private key type.
func (s *Sealer) getAlgorithm() (Algorithm, string, error) {
	switch s.PrivateKey.(type) {
	case *rsa.PrivateKey:
		return AlgRSASHA256, "sha256", nil
	case ed25519.PrivateKey:
		return AlgEd25519SHA256, "sha256", nil
	case *ecdsa.PrivateKey:
		return AlgECDSASHA256, "sha256", nil
	default:
		return "", "", fmt.Errorf("%w: unsupported key type %T", ErrAlgorithmUnknown, s.PrivateKey)
	}
}

// now returns the current time.
func (s *Sealer) now() time.Time {
	if s.Clock != nil {
		return s.Clock()
	}
	return time.Now()
}

// signWithKey signs data with the given private key.
func signWithKey(key crypto.Signer, hash crypto.Hash, data []byte) ([]byte, error) {
	switch k := key.(type) {
	case *rsa.PrivateKey:
		return k.Sign(rand.Reader, data, hash)
	case ed25519.PrivateKey:
		// Ed25519 uses PureEdDSA, not pre-hashed data
		return k.Sign(rand.Reader, data, crypto.Hash(0))
	case *ecdsa.PrivateKey:
		return ecdsa.SignASN1(rand.Reader, k, data)
	default:
		return nil, fmt.Errorf("%w: unsupported key type %T", ErrAlgorithmUnknown, key)
	}
}
